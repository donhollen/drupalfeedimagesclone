<?php

/**
 * @file
 * This is the module file of the Feeds Images Importer.
 */

/**
 * Implements hook_menu().
 */
function feed_image_menu() {
  $menu = array();

  $menu['admin/config/content/feeds-images/settings'] = array(
    'title' => 'Feeds Images Importer',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('feed_image_settings_form'),
    'access arguments' => array('administer site configuration'),
    'description' => 'Configure default options for Feeds Images Importer',
  );

  return $menu;
}

/**
 * Function to return the configuration page form.
 * 
 * @return array();
 */
function feed_image_settings_form() {

  $form = array();

  $form['settings'] = array(
    '#type' => 'fieldset',
    '#title' => t("Configorations for Feed Image Module:"),
  );

  $node_types = array();

  foreach (node_type_get_types() as $node) {
    $node_types[$node->type] = $node->name;
  }
  $form['settings']['on_off_box'] = array(
    '#type' => 'fieldset',
    '#title' => t("Feed Image state:"),
  );

  $form['settings']['content_types'] = array(
    '#type' => 'fieldset',
    '#title' => t("Choose content types:"),
    '#states' => array(
      'visible' => array(
        ':input[name="feed_image_state"]' => array('checked' => TRUE),
      ),
    ),
  );

  $form['settings']['on_off_box']['feed_image_state'] = array(
    '#type' => 'checkbox',
    '#title' => t('Turn on/off the module.'),
    '#description' => t('Turning the module off is going to disable it but it is not going to affect any of the already saved content.'),
    '#default_value' => variable_get('feed_image_state', ""),
  );

  $form['settings']['content_types']['feed_image_content_type'] = array(
    '#type' => 'checkboxes',
    '#options' => $node_types,
    '#title' => t('What content types do you want to use this module with?'),
    '#default_value' => variable_get('feed_image_content_type', array()),
    '#description' => t('All the content types that are chosen are going to have images attached to their image fields when they are generated with Feeds module. If the Image Field is set to multiple all the available images are to be dowlnoaded.'),
  );

  $form['settings']['choose_field'] = array(
    '#type' => 'fieldset',
    '#description' => t('List of all available fields attached to the chosen content types.'),
    '#title' => t("Choose Fields for images to be attached:"),
    '#states' => array(
      'visible' => array(
        ':input[name="feed_image_state"]' => array('checked' => TRUE),
      ),
    ),
  );

  // Get all the fields from the content type.
  $instances = field_info_instances('node');
  $fields = array();
  foreach ($instances as $types) {
    foreach ($types as $field) {
      $fields[$field['bundle']][$field['field_name']] = $field['label'] . " (" . $field['field_name'] . ")";
    }
  }

  if (!empty($types)) {
    foreach ($node_types as $machine_name => $name) {

      $form['settings']['choose_field'][$machine_name] = array(
        '#type' => 'fieldset',
        '#title' => t($name . ":"),
        '#states' => array(
          'visible' => array(
            ':input[name="feed_image_content_type[' . $machine_name . ']"]' => array('checked' => TRUE),
          ),
        ),
      );

      $form['settings']['choose_field'][$machine_name]['feed_image_' . $machine_name] = array(
        '#type' => 'radios',
        '#options' => $fields[$machine_name],
        '#default_value' => variable_get('feed_image_' . $machine_name, ""),
        '#required' => FALSE,
        '#description' => t("It is a MUST to choose a field of type 'image'."),
      );
    }
  }

  return system_settings_form($form);
}

/**
 * Validation for the settings form.
 * 
 * @param type $form
 * @param type $form_state
 */
function feed_image_settings_form_validate($form, &$form_state) {
  foreach ($form_state['values']['feed_image_content_type'] as $key => $value) {
    if ($value != '0' && $form_state['values']['feed_image_' . $key] == NULL) {
      form_set_error($key, t('You have to choose Fields for all chosen content types to be applied.'));
    }
  }
}

/**
 * Implements hook_feeds_after_save().
 */
function feed_image_feeds_after_save(FeedsSource $source, $entity, $item, $entity_id) {
  // Load the node.
  $node = node_load($entity->nid);

  $alowed_nodes = variable_get('feed_image_content_type');
  $feed_image_state = variable_get('feed_image_state');

  // If the module is activated and the content is chosent for pictures to be added.
  // Than go and add them, else just go out.
  if ($alowed_nodes[$node->type] == $node->type && $feed_image_state == 1) {

    // Make changes to the node that was just saved.
    // Geting the link of the XML.
    $feedUrldb = db_select('feeds_source', 'fs')
        ->distinct()
        ->fields('fs', array('source', 'imported'));

    // Link of the XML.
    $feed_url = $feedUrldb->execute()->fetchAssoc();

    // XML source code.
    $xml = file_get_contents($feed_url['source']);
    // array to store the matches
    $matches = array();

    // Regex for matching all different feed items.
    $allItems = "/(?:<item>)(.*?)(?:<\\/item>)/s";

    preg_match_all($allItems, $xml, $matches);

    foreach ($matches[0] as $match) {
      if (strpos($match, $node->title) != false) {
        $xml = $match;
        break;
      }
    }

    // Matching the urls of the images.
    $regexRSSImages1 = "/(?:<image>.*<url>)(.*)(?:<\\/url>)/";
    $regexRSSImages2 = "/(?:url=\")(.*)(?:\"\\/>)/";

    if (!preg_match($regexRSSImages1, $xml)) {
      preg_match_all($regexRSSImages2, $xml, $matches);
    }
    else {
      preg_match_all($regexRSSImages1, $xml, $matches);
    }

    // Urls of the images to be dowloaded and saved to the fiulesystem.
    $imagesUrls = $matches[1];

    $field_macine_name = variable_get('feed_image_' . $node->type); // = field_images
    // The actual URL where the image is, it is than used so that image can be dowloaded.
    // Than it can be stored into drupal's filesystem and can be found by other modules snd hooks.
    foreach ($imagesUrls as $url) {
      $file = system_retrieve_file($url, 'public://', true, FILE_EXISTS_REPLACE);

      file_usage_add($file, 'file', 'node', $node->nid);

      // Associating the current node with all the files that were targeted so they can be loaded later in the node.
      $node->{$field_macine_name}[LANGUAGE_NONE][] = array(
        'fid' => $file->fid,
        'filename' => $file->filename,
        'uid' => 1,
        'uri' => $file->uri,
        'status' => 1
      );
    }

    // Finish changes and save the node.
    node_save($node);
  }
}
